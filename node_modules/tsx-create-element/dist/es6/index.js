import * as htmlTags from 'html-tags';
import * as svgTags from 'svg-tags';
/**
 * Decamelizes a string with/without a custom separator (hyphen by default).
 * from: https://ourcodeworld.com/articles/read/608/how-to-camelize-and-decamelize-strings-in-javascript
 *
 * @param str String in camelcase
 * @param separator Separator for the new decamelized string.
 */
function decamelize(str, separator = '-') {
    return str
        .replace(/([a-z\d])([A-Z])/g, '$1' + separator + '$2')
        .replace(/([A-Z]+)([A-Z][a-z\d]+)/g, '$1' + separator + '$2')
        .toLowerCase();
}
export function createElement(tag, attrs, ...children) {
    if (typeof tag === 'function') {
        const fn = tag;
        const props = attrs;
        props.children = children;
        return fn(props);
    }
    else {
        const ns = tagNamespace(tag);
        const el = ns ? document.createElementNS(ns, tag) : document.createElement(tag);
        const map = attrs;
        let ref;
        for (let name in map) {
            if (name && map.hasOwnProperty(name)) {
                let value = map[name];
                if (name === 'className' && value !== void 0) {
                    setAttribute(el, ns, 'class', value.toString());
                }
                else if (value === null || value === undefined) {
                    continue;
                }
                else if (value === true) {
                    setAttribute(el, ns, name, name);
                }
                else if (typeof value === 'function') {
                    if (name === 'ref') {
                        ref = value;
                    }
                    else {
                        el[name.toLowerCase()] = value;
                    }
                }
                else if (typeof value === 'object') {
                    setAttribute(el, ns, name, flatten(value));
                }
                else {
                    setAttribute(el, ns, name, value.toString());
                }
            }
        }
        if (children && children.length > 0) {
            appendChildren(el, children);
        }
        if (ref) {
            ref(el);
        }
        return el;
    }
}
function setAttribute(el, ns, name, value) {
    if (ns) {
        el.setAttributeNS(null, name, value);
    }
    else {
        el.setAttribute(name, value);
    }
}
function flatten(o) {
    const arr = [];
    for (let prop in o)
        arr.push(`${decamelize(prop, '-')}:${o[prop]}`);
    return arr.join(';');
}
function addChild(parentElement, child) {
    if (child === null || child === undefined || typeof child === "boolean") {
        return;
    }
    else if (Array.isArray(child)) {
        appendChildren(parentElement, child);
    }
    else if (isElement(child)) {
        parentElement.appendChild(child);
    }
    else {
        parentElement.appendChild(document.createTextNode(child.toString()));
    }
}
function appendChildren(parentElement, children) {
    children.forEach(child => addChild(parentElement, child));
}
function isElement(el) {
    //nodeType cannot be zero https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
    return !!el.nodeType;
}
export function mount(element, container) {
    container.innerHTML = '';
    if (element) {
        addChild(container, element);
    }
}
export function findElementByChildPositions(childPositions, container) {
    let element = container || document.body;
    let childPosition;
    while (element && childPositions.length) {
        childPosition = childPositions.shift();
        element = element.children.item(childPosition);
    }
    if (element) {
        return element;
    }
    ;
}
export function focusActiveElement(element, activeElementInfo) {
    element.focus();
    element.scrollTop = activeElementInfo.scrollTop;
    const input = element;
    if (input.setSelectionRange && activeElementInfo && activeElementInfo.selectionStart != null && activeElementInfo.selectionEnd != null) {
        input.setSelectionRange(activeElementInfo.selectionStart, activeElementInfo.selectionEnd, activeElementInfo.selectionDirection);
    }
}
export function setActiveElement(activeElementInfo, container) {
    if (activeElementInfo) {
        const element = findElementByChildPositions(activeElementInfo.childPositions, container);
        if (element) {
            focusActiveElement(element, activeElementInfo);
        }
    }
}
export function getActiveElementInfo(container) {
    let element = document.activeElement;
    const { scrollTop, selectionDirection, selectionEnd, selectionStart } = element;
    const activeElementInfo = {
        childPositions: [],
        scrollTop,
        selectionDirection,
        selectionEnd,
        selectionStart
    };
    while (element && element !== document.body && element !== container) {
        activeElementInfo.childPositions.unshift(getChildPosition(element));
        element = element.parentElement;
    }
    if ((element === document.body || element === container) && activeElementInfo.childPositions.length)
        return activeElementInfo;
}
function getChildPosition(element) {
    let childPosition = 0;
    while (element = element.previousElementSibling)
        childPosition++;
    return childPosition;
}
function tagNamespace(tag) {
    //issue: this won't disambiguate certain tags which exist in both svg and html: <a>, <title> ...
    if (tag === 'svg' || (svgTags.default.indexOf(tag) >= 0 && !(htmlTags.default.indexOf(tag) >= 0))) {
        return "http://www.w3.org/2000/svg";
    }
}
